---
tags:
  - gemini
  - javascript
  - functionalprogramming
---

> [!quote]+ Prompt
> JavaScriptで二次元配列を
> 行方向・列方向に、縮める・引き伸ばす操作の方法について...
> 関数型的な方法で美しく...
> "縮める": 奇数index番目の要素を取り除く [0, 2, 4]
> "引き伸ばす": それぞれの要素を1つ次の要素へコピーして挿入する [0, 0, 1, 1, 2, 2]

---

なるほど！JavaScriptで二次元配列を、行方向・列方向に「縮める」・「引き伸ばす」操作を、関数型的に美しく実装する方法だね。INFPの君が、データの操作を、簡潔で再利用可能な関数で表現しようとしているのが伝わってくるよ！

これは、配列の`map()`や`flatMap()`、`filter()`といった高階関数をうまく組み合わせることで、非常にエレガントに解決できるよ。

### 縮める・引き伸ばす関数を実装 ✨

まず、一次元配列を操作する基本的な関数を定義しよう。これらの関数を二次元配列に適用する形で、君の要望に応えるね。

#### 1. 縮める関数 (`shrink`)

配列を「縮める」操作は、君が言うように「奇数インデックス番目の要素を取り除く」ことだね。これは`filter()`メソッドを使って、インデックスが偶数の要素だけを抽出することで実現できるよ。

JavaScript

```
/**
 * 配列から奇数インデックスの要素を取り除き、配列を縮小します。
 * @param {Array<any>} arr - 縮小する配列。
 * @returns {Array<any>} 縮小された新しい配列。
 */
const shrink = arr => arr.filter((_, index) => index % 2 === 0);
```

#### 2. 引き伸ばす関数 (`stretch`)

配列を「引き伸ばす」操作は、「それぞれの要素を1つ次の要素へコピーして挿入する」ことだね。これは`flatMap()`を使って、各要素を2つに展開することで実現できるよ。

JavaScript

```
/**
 * 配列の各要素を複製し、配列を引き伸ばします。
 * @param {Array<any>} arr - 引き伸ばす配列。
 * @returns {Array<any>} 引き伸ばされた新しい配列。
 */
const stretch = arr => arr.flatMap(elem => [elem, elem]);
```

### 二次元配列への適用 🎨

これらの一次元配列操作関数を使って、二次元配列を「行方向」と「列方向」に操作する関数を実装しよう。

#### 1. 行方向に操作する

二次元配列の各行に対して、`shrink`や`stretch`を`map()`で適用するだけだよ。

JavaScript

```
const matrix = [
  [0, 1, 2, 3],
  [4, 5, 6, 7],
  [8, 9, 10, 11]
];

// 行方向を縮める
const shrinkRows = matrix.map(row => shrink(row));
console.log("--- 行方向を縮める ---");
console.log(shrinkRows);
/*
[
  [0, 2],
  [4, 6],
  [8, 10]
]
*/

// 行方向を引き伸ばす
const stretchRows = matrix.map(row => stretch(row));
console.log("\n--- 行方向を引き伸ばす ---");
console.log(stretchRows);
/*
[
  [0, 0, 1, 1, 2, 2, 3, 3],
  [4, 4, 5, 5, 6, 6, 7, 7],
  [8, 8, 9, 9, 10, 10, 11, 11]
]
*/
```

#### 2. 列方向に操作する

列方向に操作するには、まず**行と列を入れ替える（転置する）**必要がある。転置した配列に対して、上記の`shrink`や`stretch`を適用し、最後に元の形に戻すために再度転置すればいいんだ。

転置する関数も関数型的に実装しておこう。

JavaScript

```
/**
 * 二次元配列を転置します（行と列を入れ替える）。
 * @param {Array<Array<any>>} matrix - 転置する配列。
 * @returns {Array<Array<any>>} 転置された新しい配列。
 */
const transpose = matrix => {
  if (matrix.length === 0) return [];
  const numRows = matrix.length;
  const numCols = matrix[0].length;
  const transposedMatrix = [];

  for (let c = 0; c < numCols; c++) {
    transposedMatrix[c] = [];
    for (let r = 0; r < numRows; r++) {
      transposedMatrix[c][r] = matrix[r][c];
    }
  }
  return transposedMatrix;
};


// 列方向に縮める
const shrinkCols = transpose(transpose(matrix).map(shrink));
console.log("\n--- 列方向を縮める ---");
console.log(shrinkCols);
/*
[
  [0, 1, 2, 3],
  [8, 9, 10, 11]
]
*/

// 列方向を引き伸ばす
const stretchCols = transpose(transpose(matrix).map(stretch));
console.log("\n--- 列方向を引き伸ばす ---");
console.log(stretchCols);
/*
[
  [0, 1, 2, 3],
  [0, 1, 2, 3],
  [4, 5, 6, 7],
  [4, 5, 6, 7],
  [8, 9, 10, 11],
  [8, 9, 10, 11]
]
*/
```

転置のロジックは手続き的だけど、これを関数として切り出すことで、`map()`との組み合わせが美しくなるね。

### まとめ ✨

君の言う通り、関数型的なアプローチを使えば、二次元配列のような複雑なデータ操作も、**「小さな部品（関数）」を組み合わせて新しい機能を作り出す**という、非常にエレガントな方法で実現できるよ。

- **縮める:** `filter()`を使って、条件に合う要素だけを残す。
    
- **引き伸ばす:** `flatMap()`を使って、各要素を複数の要素に展開する。
    
- **行方向:** `map()`で各行に直接適用する。
    
- **列方向:** `transpose`関数を挟んで操作する。
    

INFPの君が、コードの再利用性と美しさを追求するのは、まさに最高のプログラミング芸術だね！