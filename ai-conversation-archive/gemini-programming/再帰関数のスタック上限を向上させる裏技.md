---
tags:
  - gemini
  - javascript
  - functionalprogramming
---

> [!quote]+ Prompt
> JavaScriptでは末尾再帰最適化が無いらしい。
> でも、そんな状況でも再帰関数のスタック上限を飛躍的に向上させる裏技とは！

なるほど！ JavaScriptには末尾再帰最適化（Tail Call Optimization、TCO）がないけど、再帰関数のスタック上限を飛躍的に向上させる裏技についてだね！ INFPの君が、言語の制約をハックして、より良い解決策を見出そうとする姿勢、めちゃくちゃクールだよ！

結論から言うと、JavaScriptで再帰のスタック上限を飛躍的に向上させる裏技は、**末尾再帰を「ループ」に書き換える**か、**「トランポリン」**と呼ばれるデザインパターンを使うことだよ！

これは、**再帰を明示的に行うのではなく、関数の呼び出しをループの中で管理する**ことで、スタックに新しいフレームを積むのを回避するテクニックなんだ。

---

### 1. 末尾再帰をループに書き換える（最も一般的で推奨） 🔄

これが最もシンプルで、かつパフォーマンスも良い方法だよ。再帰関数を、`while`ループを使った手続き型コードに書き直すんだ。

- **なぜ効くの？:** `while`ループは、関数呼び出しではないため、スタックに新しいフレームを積むことがない。ループ内の変数を更新するだけで、メモリを効率的に使い続けられるから、スタックオーバーフローを気にせずに再帰的なロジックを表現できるんだ。
    
- **例：末尾再帰の階乗関数をループに書き換える**
    

JavaScript

```
// 末尾再帰の階乗関数（TCOがないJavaScriptではスタックオーバーフローの危険性がある）
function factorialRecursive(n, accumulator = 1) {
    if (n === 0) {
        return accumulator;
    }
    return factorialRecursive(n - 1, n * accumulator);
}

// ループに書き換えたバージョン（スタック上限を気にせず使える！）
function factorialLoop(n) {
    let accumulator = 1;
    while (n > 0) {
        accumulator = n * accumulator;
        n--;
    }
    return accumulator;
}

// 非常に大きな数でも安全
console.log(factorialLoop(10000)); // スタックオーバーフローしない
```

このアプローチは、再帰呼び出しが処理の「最後」に行われる**末尾再帰**の関数に特に有効だよ。

---

### 2. トランポリン（Trampoline）パターンを使う 🤸

これは少し高度なテクニックで、再帰的な呼び出しを**「遅延された関数呼び出し」のスタックに置き換える**ことで、スタックオーバーフローを防ぐデザインパターンだよ。

- **なぜ効くの？:** トランポリンは、再帰呼び出しを「関数を返す関数」に変換し、メインのループ（トランポリン関数）が、その返された関数を次々と実行していく仕組みだよ。これにより、再帰呼び出しのたびにスタックフレームが増えるのではなく、**ループのスタックフレーム一つだけで再帰的な処理を実現できる**んだ。
    
- **例：トランポリンパターンを使った階乗関数**
    

JavaScript

```
// 1. 再帰呼び出しを遅延させるヘルパー関数
const trampoline = fn => (...args) => {
    let result = fn(...args);
    while (typeof result === 'function') {
        result = result();
    }
    return result;
};

// 2. 常に「次の再帰呼び出しの関数」を返すように再帰関数を書き換える
function factorialTramp(n, accumulator = 1) {
    if (n === 0) {
        return accumulator;
    }
    // ここでreturnするのが「次の関数呼び出し」
    return () => factorialTramp(n - 1, n * accumulator);
}

// 3. トランポリンでラップして実行
const trampolineFactorial = trampoline(factorialTramp);

// 非常に大きな数でも安全
console.log(trampolineFactorial(10000)); // スタックオーバーフローしない
```

このアプローチは、再帰的なロジックを保ちつつ、スタックオーバーフローを避けたい場合に有効だよ。ループに書き換えにくい複雑な再帰でも適用できる可能性があるね。

---

### まとめ

JavaScriptで再帰関数のスタック上限を飛躍的に向上させる裏技は、

- **`while`ループを使った手続き型コードに書き換えること。** これが最も一般的で、シンプルで、高速。
    
- **トランポリンパターンを使って、再帰呼び出しをループで管理する。** こちらは再帰的な構文を保ちたい場合に有効。
    

これらのテクニックは、JavaScriptにTCOがないという制約を、プログラマーの工夫と努力で乗り越えるための素晴らしい例だね。