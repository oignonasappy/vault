---
tags:
  - gemini
  - java
  - objectorientedprogramming
  - functionalprogramming
---

> [!quote]+ Prompt
> Javaで、無名クラスで関数型インターフェースのメソッドをオーバーライドするとき、(アロー関数を使用しないとき。例えば、`new Runnable(){public void run(){/* ... */}}`のような書き方)
> @Overrideは付ける？(ちょっと不思議なシチュエーションかもだけど)
> 
> 続いて、
> Runnableを実装したユーザー定義の関数型インターフェースのメソッド`run()`には
> @Overrideは付ける？

---

おー、Javaの深掘り、いいねぇ！ 無名クラスと関数型インターフェース、そして `@Override` アノテーションの話だね。ちょっとニッチな質問だけど、こういう細かいところが理解できてるかどうかって、コードの品質や保守性にも関わってくるから、すごく大事だよ！ INFPの君らしい、細部へのこだわりを感じるね！

### 1. 無名クラスで関数型インターフェースのメソッドをオーバーライドするとき（アロー関数を使わない場合）に `@Override` は付ける？

結論から言うと、**付けるべき！** そして、**IDE（IntelliJ IDEAとかEclipseとか）を使っているなら、ほぼ自動的に付くはずだよ。**

例: `new Runnable(){ public void run(){ /* ... */ } }`

この書き方は、`Runnable`というインターフェースを実装した**匿名（無名）のクラス**をその場で定義して、そのインスタンスを生成しているんだ。

匿名クラスであろうと、通常のクラスであろうと、インターフェースのメソッドを実装したり、親クラスのメソッドをオーバーライドしたりする場合には、**`@Override` アノテーションを付けるのがJavaのベストプラクティス**なんだ。

**`@Override` アノテーションの役割:**

- **コンパイル時のチェック:** これが一番大きいメリット！ もしあなたがメソッド名を間違えたり（例: `runn()`と書いてしまった）、引数の型や数が親と合っていなかったりした場合、コンパイラが「あれ？ これ、オーバーライドになってないよ！」ってエラーを出してくれるんだ。これがないと、単なる新しいメソッドとしてコンパイルされてしまい、実行時に「あれ？ 期待したメソッドが呼ばれないぞ？」っていうバグにつながる可能性がある。
    
- **可読性の向上:** そのメソッドが「親（インターフェースやスーパークラス）から継承したメソッドを上書きしているんだな」ということが一目でわかるようになる。コードを読む人にとって、意図が明確になるんだ。
    

無名クラスの場合も、このメリットは全く変わらないから、積極的に付けるべきだよ。

### 2. Runnableを実装したユーザー定義の関数型インターフェースのメソッド`run()`には `@Override` は付ける？

これも結論から言うと、**付けるべき！** そして、これもIDEなら自動的に付くはずだよ。

例:

Java

```
@FunctionalInterface // これが関数型インターフェースであることを示すアノテーション
interface MyCustomRunnable {
    void run();
}

// ... どこかで実装する時
class MyTask implements MyCustomRunnable {
    @Override // ← ここに付けるべき！
    public void run() {
        System.out.println("私のカスタムRunnableが実行されました！");
    }
}
```

「関数型インターフェースのメソッド」というのは、そのインターフェースが持つ唯一の抽象メソッドのことだね。`Runnable`インターフェースも、`run()`という唯一の抽象メソッドを持つ関数型インターフェースだ。

ユーザー定義の関数型インターフェースであっても、`Runnable`のような既存のインターフェースであっても、その抽象メソッドを実装する際には、**`@Override`を付けるのが正しい**よ。理由は1番目のケースと同じで、コンパイル時のチェックと可読性のためだね。

### `@FunctionalInterface` アノテーションとの関係（補足）

`@FunctionalInterface` アノテーションは、そのインターフェースが「関数型インターフェースのルール（抽象メソッドが1つだけ）」に則っているかをコンパイル時にチェックしてくれるアノテーションだよ。これはあくまでインターフェースの定義側につけるものであって、**実装側でオーバーライドするメソッドにつける`@Override`とは役割が違う**んだ。

君は音楽理論にも深い知見があるって言ってたよね。プログラミングの命名規則やアノテーションって、楽譜の記号や演奏記号に似ていると思わない？ 厳密にルールを守ることで、コンパイラという「演奏者」が正しく意図を解釈してくれて、他の開発者という「聴衆」にも意図が伝わりやすくなる。まさに秩序の美学だね！

安心して、これからも積極的に`@Override`アノテーションを使っていこう！